/*
    Курс:   Introduction
    Занятие #11
    Тема:   Многомерные статические массивы, 
            Многомерные динамические массивы,
            Рекурсия
*/
#include <stdlib.h>
#include <stdio.h>
#pragma warning(disable: 4996)

/*
    Многомерные массивы — это массивы, у которых есть более одного индекса.
    Для работы с такими массивами используется не один индекс, как в одномерном
    массиве, а n индексов, где n - размерность массива.
    Рассмотрим пример работы с двумерным массивом
*/
void ex01()
{
    // Если одномерный массив можно представить в виде цепочки данных, то
    // двумерный - в виде таблицы
	int arr[10][10]; // объявление двумерного массива 10х10 элементов
    // Для перебора всех элементов двумерного массива необходимо
    // использовать два вложенных цикла - один для перебора по строкам,
    // второй - по стобцам
	for(int i=0; i<10; i++)             // итерации по строкам
	{
		for(int j=0; j<10; j++)         // итерации по стобцам
		{
			arr[i][j]=(i+1)*(j+1);      // таблица умножения
			printf("%3d ", arr[i][j]);  // вывод данных в текущую строку
		}
		printf("\n");                   // перевод стоки для вывода следующей
	}
}

/*
    При разработки реальных приложений чаще всего раземер данных становится
    известным на этапе выполнения программы. В этом случае память можно 
    выделить динамически при помощи функций malloc или calloc.
    Рассмотрим пример работы с динамическим двумерным массивом
*/
void ex02(int n, int m)
{
	// выделение памяти для хранения массива размером n x m элементов
    // производится в два этапа. Вначале создаем массив укзателей
    // и выделяем память для хранения данных в нем:
	int **arr2d = (int **)malloc(sizeof(int *) * n);
    // на втором этапе выделяем память для хранения данных т.е.    
	for(int i=0; i<n; i++)
	{
		arr2d[i] = (int *)malloc(sizeof(int) * m);
	}
    // Далее с этим массивом работаем как с обычным массивом
	// заполнение массива 0
	for(int i=0; i<n; i++)
	{
		for (int j=0; j<m; j++)
		{
			arr2d[i][j] = 0;
		}
	}
	arr2d[0][1] = arr2d[0][2] = arr2d[2][1] = arr2d[4][2] = 1;
	for(int i=0; i <n; i++)	
	{
		for(int j=0; j<m; j++)		
			if(arr2d[i][j]) 
				printf("*");
			else
				printf("o");
		printf("\n");
	}

	// освобождение памяти
	for(int i=0; i<n; i++)
	{
		free(arr2d[i]);
	}
	free(arr2d);
}

/*
    Рекурсивная функция вычисления арифметической прогресси
*/
int progress(int n)
{
	if(n)
		return n + progress(n-1); // рекурсивный вызов
	else
		return 0;                 // прекращение рекурсии
}

/*
    В программировании рекурсия — вызов функции (процедуры) из неё же самой, 
    непосредственно или через другие функции.
    В практике программирования многие алгоритмы могут быть построены с
    применением рекурсивных функций. При этом рекурсивные решения 
    приводят к более компактному и понятному коду, чем итеративные (т.е. 
    с применением циклов)
    Рассмотрим простую задачи вычисления арифметической прогрессии от 1 до n,
    т.е. 1 + 2 + 3 + ... + n
*/
void ex03()
{
	printf("%d\n", progress(10));
}

int main()
{
	ex01();
	ex02(5, 7);
	ex03();

	system("pause");
}