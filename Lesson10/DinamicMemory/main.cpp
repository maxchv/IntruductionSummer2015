/*
    Курс:   Introduction
    Занятие #10
    Тема:   Адресная арифметика, Динамическое выделение памяти, 
            указатели на функции, сортировка пузырьком
*/
#include <stdio.h>
#include <stdlib.h>

/* 
Адресная арифметика http://www.viva64.com/ru/t/0005/
При работе с массивами вовсе не обязательно использовать оператор идексирования [].
Рассмотрим пример работы с массивами исключительно через укзатели
*/ 
void ex00()
{
    // Объявляем массив
    int arr[10];
    int *p = arr; // объявляем указатель типа int и инициализируем его адресом первого элемента
    // массива. Важно помнить, что имя массива - это то же самое, что &arr[0]
    int size = sizeof(arr)/sizeof(arr[0]); // вычисляем размер массива
    // Заполним массив значениями от 0 до 9
    for(int i=0; i<size; i++)
    {
        *p = i;
        p++; // инкремент приводит к смещению указателя к следующему элементу массива!
    }
    // Выводим массив на экран
    p = arr; // установим указатель на первый элемент массива т.к. после заполнения массива p указывает на последий элемент
    for(int i=0; i<size; i++)
    {
        printf("%d ", *(p++)); // скобки вокруг p важны.
    }
}

/* Динамическое выделение памяти
При динамическом выделении памяти, память резервируется не на этапе компиляции,
а на этапе выполнения программы. И это дает нам возможность выделять память более 
эффективно, в основном это касается массивов. С динамическим выделением память, нам 
нет необходимости заранее задавать размер массива, тем более, что не всегда известно, 
какой размер должен быть у массива.
*/
void ex01()
{
    // Задача: создать динамический массив типа int размером 5 элементов
    int n = 5;                      // размер массива
    int size = sizeof(int) * n;     // необходимый размер памяти для хранения массива, в байтах
    int *p = (int *) malloc( size ); // используем функцию malloc (memory allocation), которая возвращает
    // адрес выделенного блока памяти размером size байт
    // Функция malloc возвращает указатель типа void *, а у нас p -
    // укзатель типа int *. Для приведения типа укзателя void * к
    // указателю тиа int * перед функцией добавляем (int *)
    // теперь мы можем работать с p как с обычным массивом!    
    for(int i=0; i<n; i++) // инициализация массива значениями от 1 до 5 с шагом 1 и вывод на экран
    {		
        p[i] = i+1;
        printf("%d ", p[i]);		
    }
    // т.к. мы явно выделили память, ее также явно нужно освободить функцей free
    free(p); // если не вызвать функцию free - произойдет "утечка" памяти
}

void f1()
{ 
    printf("f1\n"); 
}

void f2()
{ 
    printf("f2\n"); 
}

/*
Указатели на функции.
При разработке реальных программ с высокой долей вероятности вам потребуется 
использовать указатели на функции. Это позволит разработать универсальный алгоритм
решения определенной задачи поведение которой можно настроить через указатели на функции.
Пример такого подхода приведен ниже при реализации функции сортировки.
Исполняемый код, как и данные, при выполнении программы находится в памяти компьютера,
поэтом точно также как мы получаем адрес памяти в которой хранятсе некие данные, также
мы можем получить и адрес любой функции.
*/
void ex02()
{
    void (*pf)(); // указатель на функцию возвращающую void и не принимающую аргументов. Скобки важны!
    pf=&f1;       // получаем адрес функции объявленной на строке 63
    pf();         // вызываем функцию f1() через указаетель
    pf = &f2;     // получаем адрес функции объявленной на строке 68
    pf();         // вызываем функцию f2() через указаетель
}

// вспомогательная ф-ция обмена данными двух аргументов
void swap(int *a, int *b) { 
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

/*
    Функция сравнения для сортировки в порядке возрастания
*/
int upstair(int a, int b) {
    return a > b;
}

/*
    Функция сравнения для сортировки в порядке убывания
*/
int downstair(int a, int b) {
    return a < b;
}

/*
    Функция сортировки методом пузырька.
    Принимает:
        arr  - указатель на массив данных
        size - размер данных в массиве arr
        cmp  - указатель на функцию сравнения
    За счет наличия третьего аргумента данные могут быть отсортированы как
    в порядке возрастания, так и в порядке убывания.
*/
void bubble_sort(int arr[], int size, int (*cmp)(int, int)) { // ф-ция сортировки пузырьком
    for(int i=0; i<size - 1; i++)	
        for(int j=0; j<size - i - 1; j++) 
            if(cmp(arr[j], arr[j+1]))//(arr[j] < arr[j+1]) 
                swap(&arr[j], &arr[j+1]);
}
/*
    Ф-ция вывода массива на экран
*/
void print_arr(int arr[], int size) {
    for(int i=0; i<size; i++) 
    {
        printf("%d ",arr[i]);
    }
    printf("\n");
}

/*
    Сортировка - частая задача, которая возникает для упорядочения данных
    Рассмотрим один из наиболее простых методов сортировки - метод пузырька.
    Больше информации о сортировке пузырьком: https://youtu.be/5JMInXAtnQg
    https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D1%83%D0%B7%D1%8B%D1%80%D1%8C%D0%BA%D0%BE%D0%BC
*/
void ex03() {
    int arr[] = {10, 5, 1, 3, 8, 7, 6, 9, 4, 2}; // массив для сортировки
    int size = sizeof(arr)/sizeof(arr[0]);       // размер массива
    bubble_sort(arr, size, &upstair);            // сортировка по возрастанию
    print_arr(arr, size);                        // вывод массива отсортированного по возрастанию
    bubble_sort(arr, size, &downstair);          // сортировка по убыванию
    print_arr(arr, size);                        // вывод массива отсортированного по убыванию
}

// основная функция из которой вызываем все примеры
int main()
{
    ex00();
    ex01();
    ex02();
    ex03();
    
    system("pause");
    return 0;
}